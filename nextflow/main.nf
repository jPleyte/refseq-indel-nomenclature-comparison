#!/usr/bin/env nextflow

// Import the processes from your modules folder
include { validateParameters; paramsSummaryLog } from 'plugin/nf-validation'
include { findGapVariants } from './modules/local/variants/find_gap_variants.nf'
include { getTfxVariants } from './modules/local/variants/get_tfx_variants.nf'
include { writeHgvsNomenclatureToCsv} from './modules/local/main/write_hgvs_nomenclature_to_csv.nf'
include { csvToAvinput } from './modules/local/main/csv_to_avinput.nf'
include { runAnnovar } from './modules/local/main/run_annovar.nf'
include { writeAnnovarNomenclatureToCsv } from './modules/local/main/write_annovar_nomenclature_to_csv.nf'
include { csvToVcf } from './modules/local/main/csv_to_vcf.nf'
include { runSnpEff } from './modules/local/main/run_snpeff.nf'
include { writeSnpEffNomenclatureToCsv } from './modules/local/main/write_snpeff_nomenclature_to_csv.nf'
include { runVep as runVepRefseq } from './modules/local/main/run_vep.nf'
include { runVep as runVepHg19 } from './modules/local/main/run_vep.nf'
include { writeVepNomenclatureToCsv as writeVepRefseqNomenclatureToCsv } from './modules/local/main/write_vep_nomenclature_to_csv.nf'
include { writeVepNomenclatureToCsv as writeVepHg19NomenclatureToCsv } from './modules/local/main/write_vep_nomenclature_to_csv.nf'
include { writeTfxNomenclatureToCsv } from './modules/local/main/write_tfx_nomenclature_to_csv.nf'
include { writeCgdNomenclatureToCsv } from './modules/local/main/write_cgd_nomenclature_to_csv.nf'
include { joinAndCompare } from './modules/local/main/join_and_compare.nf'
include { performAnalysis } from './modules/local/main/perform_analysis.nf'
include { filterNomenclature as filterHgvsNomenclature} from './modules/local/main/filter_nomenclature.nf'
include { filterNomenclature as filterAnnovarNomenclature} from './modules/local/main/filter_nomenclature.nf'
include { filterNomenclature as filterSnpeffNomenclature} from './modules/local/main/filter_nomenclature.nf'
include { filterNomenclature as filterVepRefseqNomenclature} from './modules/local/main/filter_nomenclature.nf'
include { filterNomenclature as filterVepHg19Nomenclature} from './modules/local/main/filter_nomenclature.nf'
include { filterNomenclature as filterTfxNomenclature} from './modules/local/main/filter_nomenclature.nf'
include { filterNomenclature as filterCgdNomenclature} from './modules/local/main/filter_nomenclature.nf'
include { writeExonDetail } from './modules/local/main/write_exon_detail.nf'

workflow {
    main:
    uta_schema = channel.value(params.uta_schema)
    fasta_ch = channel.fromPath(params.fasta, checkIfExists: true)
    ncbi_refseq_gff_db = channel.fromPath(params.ncbi_refseq_gff_db, checkIfExists: true)
    ncbi_refseq_gff_accession_index_df = channel.fromPath(params.ncbi_refseq_gff_accession_index_df, checkIfExists: true)

    def vep_sequence_modes = [
        refseq: "--use_transcript_ref",
        reference: "--use_given_ref"
    ]

    validateParameters()

    println "Using variant source: ${params.variant_source}"
    if (params.variant_source != 'gap_query') {
        println "Using variant source file: ${params.variant_source_file}"
    } 

    // Optional filter - list of variants and transcripts to keep 
    def filter_file_obj = params.variant_transcript_filter ? file(params.variant_transcript_filter, checkIfExists: true) : []
    // Print the status message
    if (filter_file_obj) {
        println "Using Variant Transcript Filter: ${filter_file_obj.name}"
    } else {
        println "No Variant Transcript Filter provided."
    }
    // Create the value channel
    def ch_variant_transcript_filter = channel.value(filter_file_obj)


    // Parameter validation
    if (params.variant_source_file != null && params.variant_source == 'gap_query') {
        error "You provided an input file but chose gap_query as the input method, which does not use a file."
    } else if (params.variant_source_file == null && (params.variant_source == 'csv' || params.variant_source == 'tfx')) {
        error "You indicated ${params.variant_source} as the variant_source, but did not provide a variant_source_file"
    }

    // Read variants 
    def ch_variants
    if (params.variant_source == 'csv') {
        ch_variants = params.variant_source_file
    } 
    else if (params.variant_source == 'gap_query') {
        ch_variants = findGapVariants(uta_schema, fasta_ch)
    }
    else if (params.variant_source == 'tfx') {
        ch_variants = getTfxVariants(params.variant_source_file)
    }
    else {
        error "Unknown variant source: ${params.variant_source}"
    }

    // Generate nomenclature using hgvs package. 
    // Do not generate hgvs nomenclature when input source is 'tfx' but tfx uses the same code.    
    def ch_hgvs_nomenclature_filtered = channel.empty() 
     if (params.variant_source != 'tfx') {
        hgvs_nomenclature = writeHgvsNomenclatureToCsv(fasta_ch, ch_variants)
        ch_hgvs_nomenclature_filtered = filterHgvsNomenclature(hgvs_nomenclature, ch_variant_transcript_filter)    
     }
    
    // Convert variant list to annovar avinput file 
    csvToAvinput(ch_variants)

    // Run annovar on the avinput file
    runAnnovar(csvToAvinput.out.annovar_avinput)

    // Extract annovar nomenclature and write to new csv
    def ch_annovar_raw =writeAnnovarNomenclatureToCsv(runAnnovar.out.multianno)
    def ch_annovar_filtered = filterAnnovarNomenclature(ch_annovar_raw.annovar_nomenclature, ch_variant_transcript_filter)
    
    // Convert variant list to vcf to be used by SnpEff and VEP
    csvToVcf(ch_variants)

    // Run SnpEfff on vcf 
    runSnpEff(csvToVcf.out.vcf)

    // Extract SnpEff nomenclature and write to new csv
    writeSnpEffNomenclatureToCsv(runSnpEff.out.snpeff_tsv)
    def ch_snpeff_filtered = filterSnpeffNomenclature(writeSnpEffNomenclatureToCsv.out.snpeff_nomenclature, ch_variant_transcript_filter)

    // Run VEP onece using coding sequence for reference andusing hg19 for reference 
    runVepRefseq(csvToVcf.out.vcf, params.vep_fasta, 'refseq', vep_sequence_modes.refseq)
    runVepHg19(csvToVcf.out.vcf, params.vep_fasta, 'hg19', vep_sequence_modes.reference)

    // extract VEP nomenclature and write to new csv
    writeVepRefseqNomenclatureToCsv(runVepRefseq.out.vep_output, 'refseq')
    writeVepHg19NomenclatureToCsv(runVepHg19.out.vep_output, 'hg19')

    // Filter the two VEP outputs
    def ch_vepRefSeq_filtered = filterVepRefseqNomenclature(writeVepRefseqNomenclatureToCsv.out.vep_nomenclature, ch_variant_transcript_filter)
    def ch_vepHg19_filtered = filterVepHg19Nomenclature(writeVepHg19NomenclatureToCsv.out.vep_nomenclature, ch_variant_transcript_filter)
    
    def ch_tfx_filtered = channel.empty()
    if (params.variant_source == 'tfx') {
        tfx_nomenclature = writeTfxNomenclatureToCsv(fasta_ch, params.variant_source_file)
        ch_tfx_filtered = filterTfxNomenclature(tfx_nomenclature, ch_variant_transcript_filter)
    }

    def ch_cgd_filtered = channel.empty()
    if (params.cgd_export_df != null) {
        cgd_nomenclature = writeCgdNomenclatureToCsv(params.cgd_export_df, ch_variants)
        ch_cgd_filtered = filterCgdNomenclature(cgd_nomenclature, ch_variant_transcript_filter)
    }

    def ch_all_labeled = ch_hgvs_nomenclature_filtered.map { file -> ["hgvs_uta", file] }
        .mix( ch_annovar_filtered.map { file -> ["annovar", file] } )
        .mix( ch_snpeff_filtered.map  { file -> ["snpeff", file] } )
        .mix( ch_vepRefSeq_filtered.map { file -> ["vep_refseq", file] } )
        .mix( ch_vepHg19_filtered.map   { file -> ["vep_hg19", file] } )
        .mix( ch_tfx_filtered.map       { file -> ["tfx", file] } )
        .mix( ch_cgd_filtered.map       { file -> ["cgd", file] } )

    def ch_final_tool_outputs = ch_all_labeled.toList()

    // Pirint out the list of nomenclature files
    ch_final_tool_outputs.view { list -> 
        "Collected Outputs:\n" + list.collect { tuple -> "  - $tuple" }.join("\n") 
    }

    // Write out exon position and cigar strings for every transcript    
    writeExonDetail(ncbi_refseq_gff_db, ncbi_refseq_gff_accession_index_df, ch_final_tool_outputs)
    
    // error "STOPPING WORKFLOW for debuging"

    // Compare hgvs and annovar, join hgvs, annovar, and gaps file into final output
    joinAndCompare(ch_hgvs_nomenclature_filtered.ifEmpty([]),
                   ch_annovar_filtered,
                   ch_snpeff_filtered,
                   ch_vepRefSeq_filtered,
                   ch_vepHg19_filtered,
                   ch_tfx_filtered.ifEmpty([]),
                   ch_cgd_filtered.ifEmpty([]))

    performAnalysis(ch_hgvs_nomenclature_filtered.ifEmpty([]),
                    ch_annovar_filtered,
                    ch_snpeff_filtered,
                    ch_vepRefSeq_filtered,
                    ch_vepHg19_filtered,
                    ch_tfx_filtered.ifEmpty([]),
                    ch_cgd_filtered.ifEmpty([]))
}