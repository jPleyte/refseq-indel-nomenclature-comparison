'''
Given multiple sources of nomenclture (ideally three or more) this module identifies variant-transcripts 
where a specific source (eg Tfx) deviates from a multi-source consensus (eg cgd and vep), highlighting 
potential edge cases in transcript mapping or HGVS string generation."  
'''
from rinc.util.log_config import LogConfig
import argparse
import logging.config
import pandas as pd
from functools import reduce
from dataclasses import dataclass
from natsort import index_natsorted
import numpy as np

@dataclass(slots=True, frozen=True)
class AnalysisResult():
    target_df: str
    concensus_dataframes: list[pd.DataFrame]
    target_c_dot: str
    target_p_dot: str
    concensus_c_dot_fields: list[str]
    concensus_p_dot_fields: list[str]                            
    nomenclature_df: pd.DataFrame

class OneSourceDivergence(object):
    def __init__(self):
        self._logger = logging.getLogger(__name__)
        self._data_frames: list[pd.DataFrame] = []
        self._analyses: list[AnalysisResult] = []
    
    def add_datasource(self, name, path):
        """
        Add a datasource 
        """
        df = pd.read_csv(path, dtype=str)
        df.attrs['nomenclature_tool'] = name
        
        self._logger.info(f"Read {df.shape[0]} rows for tool {name} from {path}")
        self._data_frames.append(df)

    def analyze(self):
        """
        Iterate over the dataframes of nomenclature generated by different tools 
        """
        key_columns = ['chromosome', 'position', 'reference', 'alt', 'cdna_transcript']
        df_merged = reduce(lambda left, right: pd.merge(left, right, on=key_columns, how='inner'), self._data_frames)
        print(f"Merged size={df_merged.shape[0]}")
        
        for target in self._data_frames:
            self._analyses.append(self._get_analysis(df_merged, target))

    def _get_field_name_matching(self, field: str, df: pd.DataFrame):
        """
        Find a field name in the dataframe that partially matches the field parameter (eg 'vep.c_dot' for 'c_dot') 
        """
        matches = [item for item in df.columns if field in item]
        
        if len(matches) == 0:
            raise ValueError(f"No fields matching {field} in field list for {df.attrs['nomenclature_tool']}")
        elif len(matches) > 1:
            raise ValueError(f"More than one field matches {field} in field list for {df.attrs['nomenclature_tool']}: {matches}")
        else:    
            return matches[0]
    
    def _get_analysis(self, df_merged: pd.DataFrame, target_df: pd.DataFrame):
        """
        Find the rows in df_merged where all the c_dot and p_dot values of the non-target dataframes are equal to each other, but are
        different from the c_dot and p_dot of the target. 
        """ 
        # consensus group is all the dataframes other than the "target" dataframe
        consensus_group = [x for x in self._data_frames if x.attrs['nomenclature_tool'] != target_df.attrs['nomenclature_tool']]
        
        concensus_c_dot_fields = [ self._get_field_name_matching('c_dot', x) for x in consensus_group ]
        concensus_p_dot_fields = [ self._get_field_name_matching('p_dot1', x) for x in consensus_group ]

        # Pick any c_dot and p_dot field from the consensus_group to be the "leader"; doens't matter which one because 
        # all the c_dot and p_dot in the concensus group will have the same values.                    
        concensus_leader_c_dot = concensus_c_dot_fields[0]
        concensus_leader_p_dot = concensus_p_dot_fields[0]
        
        c_consensus = df_merged[concensus_c_dot_fields].eq(df_merged[concensus_leader_c_dot], axis=0).all(axis=1)
        p_consensus = df_merged[concensus_p_dot_fields].eq(df_merged[concensus_leader_p_dot], axis=0).all(axis=1)
        
        # Figure out what the c_dot and p_dot fields are for the target df 
        target_c_dot = self._get_field_name_matching('c_dot', target_df)
        target_p_dot = self._get_field_name_matching('p_dot1', target_df)

        # 3. Define the Outlier: The candidate must not match the consensus leader
        c_diff = df_merged[target_c_dot] != df_merged[concensus_leader_c_dot]
        p_diff = df_merged[target_p_dot] != df_merged[concensus_leader_p_dot]
        
        # 4. Filter: Perfect consensus among others AND a difference in the outlier
        # (Using | because a difference in EITHER c. or p. makes it an outlier)
        mask = (c_consensus & p_consensus) & (c_diff | p_diff)
        
        result = df_merged[mask]
        print(f"Df {target_df.attrs['nomenclature_tool']} has {result.shape} rows where cDot and pDot differ from  {[x.attrs['nomenclature_tool'] for x in consensus_group]}")
        
        return AnalysisResult(target_df, 
                              consensus_group,
                              target_c_dot,
                              target_p_dot,
                              concensus_c_dot_fields,
                              concensus_p_dot_fields,                            
                              result)
    
    def write(self, output_file):
        """
        Write the results to a spreadsheet giving one sheet to each dataframe that was compared to the rest. 
        """
        with pd.ExcelWriter(output_file, engine='openpyxl') as writer:
            summary_df = self._get_summary_df()
            summary_df.to_excel(writer, sheet_name='Summary', index=False)

            for r in self._analyses:
                if not r.nomenclature_df.empty:
                    r_df = self._get_result_df_sheet(r)
                    r_df.to_excel(writer, f"{r.target_df.attrs['nomenclature_tool']}", index=False)
        
        self._logger.info(f"Wrote results to {output_file}")
                
    def _get_result_df_sheet(self, result: AnalysisResult):
        """
        """
        front_columns = ['chromosome', 'position', 'reference', 'alt', 'cdna_transcript']
        front_columns.append(result.target_c_dot)
        front_columns.extend(result.concensus_c_dot_fields)
        front_columns.append(result.target_p_dot)
        front_columns.extend(result.concensus_p_dot_fields)
        front_columns.extend([x for x in result.nomenclature_df.columns if x not in front_columns])
        
        df_sheet = result.nomenclature_df[front_columns]
        
        sort_columns = ['chromosome', 'position', 'reference', 'alt', 'cdna_transcript']
        return df_sheet.sort_values(by=sort_columns, 
                                    ascending=True, 
                                    key=lambda x: np.argsort(index_natsorted(x)))
        
    def _get_summary_df(self):
        """
        Return a summary dataframe
        """        
        summaries = []
        for analysis_result in self._analyses:
            summary = {}
            summary['target'] = analysis_result.target_df.attrs['nomenclature_tool']
            summary['concensus_sources'] = '|'.join(x.attrs['nomenclature_tool'] for x in analysis_result.concensus_dataframes)
            summary['variant_transcripts'] = analysis_result.nomenclature_df.shape[0]
            summaries.append(summary)
        
        return pd.DataFrame(summaries)
            

def _parse_args():
    parser = argparse.ArgumentParser(description='Read Annovar multianno file, extract values and write to new csv')

    parser.add_argument('--nomenclature', action='append', nargs=2, metavar=('NAME', 'PATH'), help="Pass nickname followed by path to CSV", required=True)    
    parser.add_argument("--out", help="output file (xlsx)", dest="output", required=True)

    parser.add_argument("--version", action="version", version="0.0.1")

    return parser.parse_args()

    
def main():
    logging.config.dictConfig(LogConfig().stdout_config)
    
    args = _parse_args()
    
    osd = OneSourceDivergence()
    
    if args.nomenclature:
        for name, path in args.nomenclature:
            osd.add_datasource(name, path)
    
    osd.analyze()
    osd.write(args.output)
    

if __name__ == '__main__':
    main()